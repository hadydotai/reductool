use anyhow::Result;
use futures::future::BoxFuture;
use linkme::distributed_slice;
use serde_json::Value;

/// Attribute macro to register a free-standing Rust function as an AI tool.
///
/// Usage:
/// ```rust
/// use reductool::aitool;
///
/// #[aitool]
/// /// Add two numbers
/// fn add(a: i32, b: i32) -> i32 { a + b }
/// ```
///
/// Notes:
/// - Only free functions are supported (no `self` receiver).
/// - Parameters must be simple identifiers like `arg: T`. Patterns such as `(_: T)`, `(a, b): (T, U)`, or `S { x, y }: S` are rejected.
/// - Optional parameters are expressed as `Option<T>` and will be omitted from the generated `"required"` list.
/// - Supported parameter type mappings to JSON Schema are documented in this crate’s README under “Supported parameter types”.
pub use reductool_proc_macro::aitool;

// Re-export linkme under a stable path for the generated macro code
pub use linkme as __linkme;

/// Boxed async result produced by an aitool invocation. Resolves to a `serde_json::Value` or an error.
pub type InvokeFuture = BoxFuture<'static, Result<Value>>;

/// Runtime definition of a registered AI tool.
///
/// Values of this type are generated by the `#[aitool]` macro and linked into
/// the `ALL_TOOLS` distributed slice at compile time.
#[derive(Clone)]
pub struct ToolDefinition {
    /// Tool name (function identifier), used to dispatch the tool, e.g. `"add"`.
    pub name: &'static str,
    /// Human-readable description aggregated from the function’s Rustdoc comments.
    pub description: &'static str,
    /// JSON string containing the JSON Schema for this tool’s parameters.
    pub json_schema: &'static str,
    /// Invoker that deserializes arguments and executes the function, returning its JSON value.
    pub invoke: fn(Value) -> InvokeFuture,
}

/// Registry of all tools discovered via the `#[aitool]` attribute.
///
/// Implemented as a `linkme` distributed slice so tools can be defined across crates
/// and automatically linked into a single registry.
#[distributed_slice]
pub static ALL_TOOLS: [ToolDefinition] = [..];

/// Produce the aggregated JSON Schema for all registered tools.
///
/// Returns:
/// - A JSON array where each element is the parsed schema of a tool (as `serde_json::Value`).
///
/// Panics:
/// - If a tool’s embedded `json_schema` string fails to parse (should never happen; generated by the macro).
///
/// Example:
/// ```rust
/// let schema = reductool::tools_to_schema();
/// assert!(schema.is_array());
/// ```
pub fn tools_to_schema() -> Value {
    Value::Array(
        ALL_TOOLS
            .iter()
            .map(|t| serde_json::from_str(t.json_schema).unwrap())
            .collect(),
    )
}

/// Invoke a registered tool by name with JSON arguments.
///
/// Parameters:
/// - `name`: Tool name as exposed by the annotated function identifier.
/// - `args`: JSON arguments object matching the tool’s schema.
///
/// Returns:
/// - On success, the function’s return value serialized as `serde_json::Value`.
///
/// Errors:
/// - Returns an error if no tool with the given name exists.
/// - Returns an error if the tool’s argument deserialization or execution fails.
///
/// Example:
/// ```no_run
/// async fn run() -> anyhow::Result<()> {
///     let out = reductool::dispatch_tool("add", serde_json::json!({ "a": 2, "b": 3 })).await?;
///     assert_eq!(out, serde_json::json!(5));
///     Ok(())
/// }
/// ```
pub async fn dispatch_tool(name: &str, args: Value) -> Result<Value> {
    (ALL_TOOLS
        .iter()
        .find(|t| t.name == name)
        .ok_or_else(|| anyhow::anyhow!("Unknown tool: {name}"))?
        .invoke)(args)
    .await
}
